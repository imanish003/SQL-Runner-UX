# Design ðŸŽ¨

This document captures design phase of SQL Runner application, translating ideas from [Ideation](/docs/1.%20Ideation.md) phase into a concrete design plan. The goal is to design a product that will be functional, usable and will enhance analyst productivity. This design should be scalable to accommodate future features and improvements.

## User Flow

Here is how I imagine the user flow for SQL Runner application will look like:

1. **Landing**: The user will arrive at three panel layout:
   - Collapsible Sidebar (left): I imagine this would be a collapsible sidebar that will contain various future features like saved queries, shared queries, settings etc.
   - Query Input Panel: This is where the user will write or paste their SQL queries. For now, it will be a simple text area, but in future it will be enhanced with various features outlined in ideation document.
   - Results Panel: This is where the results of executed queries will be displayed. This will be a table view. In MVP, It will show query results and all rows will be loaded at once.
2. **Query Selection/Writing**: In sidebar, for now I will show some predefined queries that user can select. Each predefined query will have a unique ID, which will be used to fetch results from [/public/data](/public/data/README.md) folder using GET request. Later, this default data could be replaced with real saved queries. Selecting a query will update the Query Input Panel with the selected query.
3. **Query Execution**: Selecting a predefined query will update the Query Input Panel with the selected query. The user can click the "Execute" button to run the query and display results in the Results Panel.
4. **Viewing Results**: After executing a query, the results will be displayed in the Results Panel. There will also be a "Clear" button to remove results from the Results Panel.

## Architecture and Design Decisions

The application will be built with Next.js and will follow feature based folder structure. This way, each feature will have its own folder containing all related components, hooks, utils etc. This will make the codebase more organized and easier to maintain, following High Coesion and Low Coupling principles.

### Key Design Choices:

1. **Three-Panel Layout**: The UI will be divided into three main sections.
   - **Sidebar (`<Sidebar />`)**: This will provide a list of predefined queries. It will be collapsible to maximize screen real estate for the editor and results. It will also have a separate mobile view for responsiveness. In future, this can be used to add more features like saved queries, shared queries, settings etc. This way, the web-app can evolve over time without major redesigns.
   - **Query Editor (`<QueryEditor />`)**: A simple `textarea` will be used for writing and editing SQL. It will be designed for quick input without the overhead of a full-fledged code editor, aligning with the goal of prioritizing core functionality. In future, It can be easily replaced with more advanced code editor like Monaco or CodeMirror if needed. Also, for better UX, I will provide resizable height for Query Editor.There will be also Maximize/Minimize button to toggle full screen mode for Query Editor.
   - **Results Panel (`<ResultsPanel />`)**: This will display query results. This will be a critical area for UX and performance. This should be able to handle large datasets using virtualization. Also, It should show loading indicator while fetching data. Similar to Query Editor, Results Panel will also have resizable height and Maximize/Minimize button to toggle full screen mode.
2. **Performance-First Results Table**: To handle potentially large datasets without crashing the browser, the `<ResultsTable />` component will implement **virtualization** using `@tanstack/react-table` and `@tanstack/react-virtual`.
   - **Virtualization**: Only the rows visible in the viewport will be rendered to the DOM. This will ensure the application remains fast and responsive even with thousands of rows.`
   - **Column Resizing**: Users will be able to drag to resize columns, a common and expected feature for data tables, which will improve readability for columns with long content.
3. **State Management**: State will be managed locally using React hooks. In future we can easily add global state management libraries like Zustand or Redux if needed. For MVP, state management libraries will be avoided to keep things simple.
4. **Component-Based UI**: The UI will be built using `shadcn/ui` components. This choice is made for several reasons:
   - **Accessibility**: `shadcn/ui` is built on Radix UI primitives, which are fully accessible (WCAG 2.1 compliant). This will cover keyboard navigation, screen reader support, and focus management out of the box.
   - **Consistency**: It provides a consistent and clean design system.
   - **Developer Experience**: Components can be easily added and customized, which will accelerate development. ShadCN provides source code for all components, this way developers can modify them as per need. This is great way to build custom design systems without reinventing the wheel.
5. **Static Data Simulation**: Since there will be no real database, all data will be stored as static JSON files in [public/data/](/public/data/README.md). The application will simulate query execution by fetching the corresponding JSON file. This will allow the focus to remain on the frontend user experience, while replicating FETCH requests that would occur in a real-world scenario.

### User Experience (UX)

One of main goal is to provide a clean, intuitive and efficient user experience. It should have great user experience even with large datasets. Here are some specific UX considerations:

- **Resizable Panels**: Plan is to provide resizable panels for Query Editor and Results Panel. This will allow users to adjust the height of each panel based on their needs. For example, if a user is working with a long query, they can allocate more space to the Query Editor. Conversely, if they are analyzing large result sets, they can expand the Results Panel.
- **Maximize/Minimize Buttons**: Each panel (Query Editor and Results Panel) will have a Maximize/Minimize button. This will allow users to toggle full screen mode for either panel, providing flexibility based on their current task. In my opinion, this will be very helpful while analyzing large datasets or writing complex queries.
- **Responsive Design**: The layout will be responsive, ensuring usability across different devices and screen sizes. The sidebar will collapse into a hamburger menu on smaller screens to maximize space for the Query Editor and Results Panel.
- **Loading and Error States**: The application will provide clear feedback during data fetching. A loading spinner will be displayed while a query is being executed, and any errors (e.g., failed fetch) will be shown in a user-friendly manner. There should be predefined queries for empty results as well as error scenarios to demonstrate these states.

## Components Breakdown

1. **Sidebar (`<Sidebar />`)**: 
   - Contains a list of predefined queries.
   - Collapsible for better screen real estate.
   - Responsive design for mobile view.
   - Future extensibility for additional features.

2. **Query Editor (`<QueryEditor />`)**:
   - Simple `textarea` for SQL input.
   - Resizable height with a draggable divider.
   - Maximize/Minimize button for full screen mode.
   - Buttons for "Execute Query" and "Clear".

3. **Results Panel (`<ResultsPanel />`)**:
   - Displays results in a table format.
   - Resizable height with a draggable divider.
   - Maximize/Minimize button for full screen mode.
   - Skeleton loader for loading state.
   - Resizable columns.
   - Virtualized rows for performance.

## Tech Stack

I decided to use the following technologies for building this application:

### **Framework**: [Next.js 15](https://nextjs.org)

Next.js, this is full-stack React framework that provides server-side rendering, static site generation, and API routes out of the box. This also provides great developer experience with built-in routing, fast refresh, and easy deployment options.

### **UI Library**: `shadcn/ui`

ShadCN is built on Radix UI primitives and Tailwind CSS. Radix UI provides unstyled, accessible components that can be easily customized with Tailwind CSS. One thing I like about ShadCN is that it provides source code for all components, this way developers can modify them as per need. This is great way to build custom design systems without reinventing the wheel.

### **Table & Virtualization**:

For table, I decided to use `@tanstack/react-table` and `@tanstack/react-virtual`. Here is why:

- **Performance**: Virtualization ensures that only the rows visible in the viewport are rendered to the DOM. This will keep the application fast and responsive even with large datasets.
- **Flexibility**: `@tanstack/react-table` is headless, meaning it provides the logic and state management for tables without enforcing any specific UI. This allows for complete customization of the table's appearance and behavior.
- **Future-Proofing**: Both libraries are actively maintained and have strong community support, ensuring they will continue to receive updates and improvements. We can easily add features like sorting, filtering, pagination etc. in future. It will be very low effort to add these features because these are already supported by `@tanstack/react-table`.

### **Styling**: Tailwind CSS v4

Tailwind CSS is a utility-first CSS framework that allows for rapid UI development. It provides a set of pre-defined classes that can be composed to create custom designs without writing custom CSS. By default, I will use `shadcn/ui` components for most of the UI. But Tailwind CSS can be used for custom styling as needed.

### Other Libraries:

- **Icons**: [lucide-react](https://lucide.dev/)
- **Testing**: [Vitest](https://vitest.dev/) & [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- **Linting**: [ESLint](https://eslint.org/) with [eslint-config-next](https://nextjs.org/docs/pages/building-your-application/configuring/eslint)
- **Utilities**: [clsx](https://github.com/lukeed/clsx), [tailwind-merge](https://github.com/dcastil/tailwind-merge), [class-variance-authority](https://cva.style/) to manage conditional class names and Tailwind CSS variants. These are needed by shadcn/ui components.
- **Resizable Panels**: [react-resizable-panels](https://github.com/bvaughn/react-resizable-panels) to allow users to adjust the size of the query editor and results pane. This is used by Resizable ShadCN component.
- **Dialog & Primitives**: [@radix-ui/react-dialog](https://www.radix-ui.com/primitives/docs/components/dialog), [@radix-ui/react-separator](https://www.radix-ui.com/primitives/docs/components/separator), [@radix-ui/react-slot](https://www.radix-ui.com/primitives/docs/components/slot). These are added by components from shadcn/ui, and can be used directly if needed.

## Coding principles to follow

1. **Single Responsibility Principle**: Each component should have a single responsibility. This will make components easier to understand, test, and maintain.
2. **High Cohesion, Low Coupling**: Related functionality should be grouped together (high cohesion), while dependencies between different parts of the code should be minimized (low coupling). This will enhance maintainability and scalability.
3. **Clean Code is better than clever code**: Code should be easy to read and understand. Avoid unnecessary complexity and favor clarity.
4. **DRY (Don't Repeat Yourself)**: Avoid code duplication by creating reusable components and functions.
5. **Make sure it works first, then make it perfect**: Focus on getting the core functionality working before optimizing for performance or adding extra features. This will help to avoid premature optimization and ensure that the application meets its primary goals.

## Conclusion

I will be prioritizing core functionality and performance in this design. Also making sure that the application is accessible and provides a good user experience. Code will be organized in a way that makes it easy to maintain and extend in the future.
