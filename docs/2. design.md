# Design ðŸŽ¨

This document captures design phase of SQL Runner application, translating ideas from "./1. Ideation.md" phase into a concrete design plan. The goal is to design a product that will be functional, usable and will enhance analyst productivity. This design should be scalable to accommodate future features and improvements.

## User Flow

Here is how I imagine the user flow for SQL Runner application will look like:

1. **Landing**: The user will arrive at three panel layout:
   - Collapsible Sidebar (left): I imagine this would be a collapsible sidebar that will contain various future features like saved queries, shared queries, settings etc.
   - Query Input Panel: This is where the user will write or paste their SQL queries. For now, it will be a simple text area, but in future it will be enhanced with various features outlined in ideation document.
   - Results Panel: This is where the results of executed queries will be displayed. This will be a table view. In MVP, It will show query results and all rows will be loaded at once.
2. **Query Selection/Writing**: In sidebar, for now I will show some predefined queries that user can select. Each predefined query will have a unique ID, which will be used to fetch results from "/public/data" folder using GET request. Later, this default data could be replace with real saved queries. Selecting a query will update the Query Input Panel with the selected query.
3. **Query Execution**: Selecting a predefined query will automatically execute it and display results in Results Panel. User can also manually click on "Execute" button to run the query.
4. **Viewing Results**: The results of the executed query will be displayed in Results Panel. There will be also "Clear" button to clear results from Results Panel.

## Architecture and Design Decisions

The application will be built with Next.js and will follow feature based folder structure. This way, each feature will have its own folder containing all related components, hooks, utils etc. This will make the codebase more organized and easier to maintain.

### Key Design Choices:

1. **Three-Panel Layout**: The UI will be divided into three main sections.
   - **Sidebar (`<Sidebar />`)**: This will provide a list of predefined queries. It will be collapsible to maximize screen real estate for the editor and results. It will also have a separate mobile view for responsiveness.
   - **Query Editor (`<QueryEditor />`)**: A simple `textarea` will be used for writing and editing SQL. It will be designed for quick input without the overhead of a full-fledged code editor, aligning with the goal of prioritizing core functionality. Between Query Editor and Results Panel, there will be resizable divider to allow users to adjust the height of each panel as needed. There will be also Maximize/Minimize button to toggle full screen mode for Query Editor.
   - **Results Panel (`<ResultsPanel />`)**: This will display query results. This will be a critical area for UX and performance. There will be Maximize/Minimize button to toggle full screen mode for Results Panel.
2. **Performance-First Results Table**: To handle potentially large datasets without crashing the browser, the `<ResultsTable />` component will implement **virtualization** using `@tanstack/react-table` and `@tanstack/react-virtual`.
   - **Virtualization**: Only the rows visible in the viewport will be rendered to the DOM. This will ensure the application remains fast and responsive even with thousands of rows.`
   - **Column Resizing**: Users will be able to drag to resize columns, a common and expected feature for data tables, which will improve readability for columns with long content.
3. **State Management**: State will be managed locally using React hooks. In future we can easily add global state management libraries like Zustand or Redux if needed. For MVP, state management libraries will be avoided to keep things simple.
4. **Component-Based UI**: The UI will be built using `shadcn/ui` components. This choice is made for several reasons:
   - **Accessibility**: `shadcn/ui` is built on Radix UI primitives, which are fully accessible (WCAG 2.1 compliant). This will cover keyboard navigation, screen reader support, and focus management out of the box.
   - **Consistency**: It provides a consistent and clean design system.
   - **Developer Experience**: Components can be easily added and customized, which will accelerate development. ShadCN provides source code for all components, this way developers can modify them as per need. This is great way to build custom design systems without reinventing the wheel.
5. **Static Data Simulation**: Since there will be no real database, all data will be stored as static JSON files in `public/data/`. The application will simulate query execution by fetching the corresponding JSON file. This will allow the focus to remain on the frontend user experience.

### User Experience (UX)

The main goal is to provide a clean, intuitive and efficient user experience. It should have great user experience even with large datasets. Here are some specific UX considerations:

- **Resizable Panels**: Plan is to provide resizable panels for Query Editor and Results Panel. This will allow users to adjust the height of each panel based on their needs. For example, if a user is working with a long query, they can allocate more space to the Query Editor. Conversely, if they are analyzing large result sets, they can expand the Results Panel.
- **Maximize/Minimize Buttons**: Each panel (Query Editor and Results Panel) will have a Maximize/Minimize button. This will allow users to toggle full screen mode for either panel, providing flexibility based on their current task. In my opinion, this will be very helpful while analyzing large datasets or writing complex queries.
- **Responsive Design**: The layout will be responsive, ensuring usability across different devices and screen sizes. The sidebar will collapse into a hamburger menu on smaller screens to maximize space for the Query Editor and Results Panel.
- **Loading and Error States**: The application will provide clear feedback during data fetching. A loading spinner will be displayed while a query is being executed, and any errors (e.g., failed fetch) will be shown in a user-friendly manner. There should be predefined queries for empty results as well as error scenarios to demonstrate these states.

## Conclusion

I will be prioritizing core functionality and performance in this design. Also making sure that the application is accessible and provides a good user experience. This design should be scalable to accommodate future features and improvements.
